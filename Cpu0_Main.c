/**********************************************************************************************************************
 * \file Cpu0_Main.c
 * \copyright Copyright (C) Infineon Technologies AG 2019
 * 
 * Use of this file is subject to the terms of use agreed between (i) you or the company in which ordinary course of 
 * business you are acting and (ii) Infineon Technologies AG or its licensees. If and as long as no such terms of use
 * are agreed, use of this file is subject to following:
 * 
 * Boost Software License - Version 1.0 - August 17th, 2003
 * 
 * Permission is hereby granted, free of charge, to any person or organization obtaining a copy of the software and 
 * accompanying documentation covered by this license (the "Software") to use, reproduce, display, distribute, execute,
 * and transmit the Software, and to prepare derivative works of the Software, and to permit third-parties to whom the
 * Software is furnished to do so, all subject to the following:
 * 
 * The copyright notices in the Software and this entire statement, including the above license grant, this restriction
 * and the following disclaimer, must be included in all copies of the Software, in whole or in part, and all 
 * derivative works of the Software, unless such copies or derivative works are solely in the form of 
 * machine-executable object code generated by a source language processor.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE 
 * COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN 
 * CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS 
 * IN THE SOFTWARE.
 *********************************************************************************************************************/
#include "HYUNDAI_RESKILL.h"

IfxCpu_syncEvent g_cpuSyncEvent = 0;

unsigned int range;
unsigned char range_valid_flag = 0;
extern unsigned int CollisionDistance_CM;
extern unsigned int CollisionAlert;

__interrupt(0x0A) __vector_table(2)
void ERU0_ISR(void)
{
    // rising P00.4 (ECHO)
    if(read_port(0, 4) != 0)
    {
        // timer CCU61.T12 Start
        //                    _________
        //        echo ______|
        //                   ^
        ccu61_t12_start();

    // falling P00.4 (ECHO)
    } else {
        //             ______
        //        echo       |______
        //                   ^
        ccu61_t12_stop();

        // (1 / t_freq) * counter * 1000000 / 58  =  centimeter
        range = ((CCU61_T12.B.T12CV * 1000000) / 48828) / 58;
        CollisionDistance_CM = range;
        range_valid_flag = 1;

        ccu61_counter_reset();
    }
}

// ISR Call on 10us
__interrupt(0x0B) __vector_table(2)
void CCU60_T12_ISR(void)
{
    // end of 10us
    // reset TRIG signal on P02.6
    p02_6_out_clear();

}


int core0_main(void)
{
    IfxCpu_enableInterrupts();
    
    /* !!WATCHDOG0 AND SAFETY WATCHDOG ARE DISABLED HERE!!
     * Enable the watchdogs and service them periodically if it is required
     */
    IfxScuWdt_disableCpuWatchdog(IfxScuWdt_getCpuWatchdogPassword());
    IfxScuWdt_disableSafetyWatchdog(IfxScuWdt_getSafetyWatchdogPassword());
    
    /* Wait for CPU sync event */
    IfxCpu_emitEvent(&g_cpuSyncEvent);
    IfxCpu_waitEvent(&g_cpuSyncEvent, 1);
    
    initLED();      // P10.1, P10.2 -> red, blue led
    initButton();   // P02.1 --> SW2 input
    //initERU_SW2();  // P02.1 --> using external interrupt
    initCCU60();      // using CCU60's T12 timer to Call ISR on 10us
    initRGBLED();     // RGB LED drive
    //initVADC_G4CH7(); // ADC conversion using VADC for G4, CH7 (connected to potentionmeter)
    //initPWMLED();     // drive P10.1 using GTM (P10.1 red LED can't be used as GPIO)
    //initGTM();        // configure GTM unit

    initERU_ECHO();   // P00.4 -> Receive ECHO signal as Interrupts
    initCCU61();      // to measure ECHO pulse duration by using CCU61's T12 timer
                      //  -> start counter on ECHO rise edge, and stop on ECHO fall edge
    initUSonic();     // P02.6 Triger Signal Generation
                      // P00.4 Echo Receive by External Interrupt using ERU

    while(1)
    {
        swdelay(10000000);

        if (CollisionAlert == 1) {
            // 느리게 깜빡임
            for(unsigned int i = 0; i < 255; i++) {
                if(i % 51 == 0) {
                    P02_OUT.U |=  (0x1 << P7_BIT_LSB_IDX);
                } else {
                    P02_OUT.U &= ~(0x1 << P7_BIT_LSB_IDX);
                }
                swdelay(1000000);
            }
        } else if (CollisionAlert == 2) {
            // 빠르게 깜빡임
            for(unsigned int i = 0; i < 255; i++) {
                if(i % 5 == 0) {
                    P02_OUT.U |=  (0x1 << P7_BIT_LSB_IDX);
                } else {
                    P02_OUT.U &= ~(0x1 << P7_BIT_LSB_IDX);
                }
                swdelay(1000000);
            }
        }

        // // drive TRIG with high (P02.6)
        // p02_6_out_set();

        // // timer T12 start on CCU60
        // ccu60_t12_start();

        // // wait until receive ECHO
        // while( range_valid_flag == 0);


        // if(        range >= 60) {
        //     on_rgb_red();
        // } else if( range >= 40) {
        //     on_rgb_green();
        // } else if( range >= 20) {
        //     on_rgb_blue();
        // } else {
        //     on_rgb_white();
        // }
    }

    return (1);
}

void initLED(void)
{
    p10_1_out_mode();
    p10_2_out_mode();
}

void initButton(void)
{
    p02_0_in_mode();
    p02_1_in_mode();
}

void initERU_SW2(void) {
    // ERUȸ�� ������ ERS2ȸ�� �Է� 4���߿� P02.1�� ����
    eru0_esr2_input_sel(1);

    // falling edge and rise edge enable
    eru0_etl_edge_sel(1, 1);

    // OGU0�� ���
    eru0_ogu0_enable();

    // ���ͷ�Ʈ �켱���� �� ID����.
    eru0_int_config(0x0A, 2);

    // ���������� cpu�� ISR�Լ��� �����ϵ��� ���
    eru0_isr_enable();
}

void initERU_ECHO(void) {
    // ERUȸ�� ������ ERS2ȸ�� �Է� 4���߿� P00.4�� ����
    eru0_esr2_input_sel(2);

    // falling edge and rise edge enable
    eru0_etl_edge_sel(1, 1);

    // OGU0�� ���
    eru0_ogu0_enable();

    // ���ͷ�Ʈ �켱���� �� ID����.
    eru0_int_config(0x0A, 2);

    // ���������� cpu�� ISR�Լ��� �����ϵ��� ���
    eru0_isr_enable();
}

void initCCU60(void) {

    // unlock scu to access CLC
    unlock_scu();

    // clock enable
    ccu60_clock_enable();

    // lock scu after configuring CLC
    lock_scu();

    // wait until CCU60 module enabled
    ccu60_clock_enable_wait();

    // timer clock selection (50MHz/4=12.5Mhz, 12.5MHz/1=12.5Mhz, edge aligned mode)
    ccu60_clock_config(0x02, 0, 0);

    // setting N=125, T = 1/F * N --> ex)  1/12.5Mz * 125 = 10us
    ccu60_period_config(125-1);

    // setting single shot mode
    ccu60_single_shot_mode();

    // clear timer counter value
    ccu60_counter_clear();

    // Connect to CPU using SR0 (select SR0, SR1, SR2, SR3)
    ccu60_connect_to_cpu(0x00);

    // setting interrupt service ID and cpu number (cpu0)
    ccu60_int_config(0x0B, 2);

    // finally, start timer block.. (Run Start)
    ccu60_t12_start();
}

void initRGBLED(void)
{
    // configure P02.7 output mode to drive RED on RGB led
    p02_7_out_mode();

    // configure P10.5 output mode to drive GREEN on RGB led
    p10_5_out_mode();

    // configure P10.3 output mode to drive BLUE on RGB led
    p10_3_out_mode();

}

void initVADC_G4CH7(void) {

    // unlock scu to access CLC
    unlock_scu();

    // clock enable
    vadc_clock_enable();

    // lock scu after configuring CLC
    lock_scu();

    // wait until CCU60 module enabled
    vadc_clock_enable_wait();

    // configuring VADC G4 CH7
    //   priority: 0x03 (max)
    //
    //   start   : 0    (wait-for-start)
    //             1    (cancel-inject)
    //
    //   class   : 0    (12bit)
    //             1    (10bit)
    //             2    ( 8bit)
    vadc_g4_ch7_config(0x3, 0, 0);


    // connect g4ch7 (potentionmeter) to VADC
    g4_ch7_connect_to_vadc();
}

void initPWMLED(void)
{
    // now P02.1 is used as PWM output instead of using GPIO
    //p10_1_out_mode();
    p10_1_pwm_mode();

    // still P02.2 is GPIO to drive blue LED
    p10_2_out_mode();
}

void initGTM(void) {

    // unlock scu to access CLC
    unlock_scu();

    // clock enable
    gtm_clock_enable();

    // lock scu after configuring CLC
    lock_scu();

    // wait until CCU60 module enabled
    gtm_clock_enable_wait();

    // gtm main clock selection (0~15), 0 is fastest
    gtm_clock(0);

    // P10.1 --> connected to TOM0_CH1
    // so we have to configure tom0, ch1
    //   SL: 1 --> high duty
    //  CLK: 1 --> 100M/16=6250KHz
    //  OSM: 0 --> continuous mode
    gtm_tom0_ch1_config(1, 1, 0);

    // when setting N=12500
    //   after N counting, time will be  T = 1/F * N
    //     --> ex)  1/6250k * 12500 = 2ms -> 0.5Khz-> 500Hz
    gtm_tom0_ch1_period_config(12500-1);

    // 10% duty
    gtm_tom0_ch1_duty_config(1250-1);

    // connect tom0_ch1 to port P10.1
    tom0_ch1_connect_to_p10_1();

}

void initUSonic(void) {
    // P02.6 output mode to drive TRIG
    p02_6_out_mode();

    // P00.4 input mode to receive ECHO
    p00_4_in_mode();

    // drive P02.6 with low
    p02_6_out_clear();
}

void initCCU61(void)
{

    // unlock scu to access CLC
    unlock_scu();

    // CCU61 timer clock enable
    ccu61_clock_enable();

    // lock scu after configuring CLC
    lock_scu();

    // wait until CCU61 module enabled
    ccu61_clock_enable_wait();


    // timer clock selection (50MHz/4=12.5Mhz, 12.5MHz/256=48828Hz, edge aligned mode)
    ccu61_clock_config(0x02, 1, 0);

    // infinite value setting N=100000, T = 1/F * N --> ex)  1/12.5Mz * 10000
    ccu61_period_config(100000-1);

    // clear timer counter value
    ccu61_counter_clear();

}

